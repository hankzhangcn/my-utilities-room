数据结构速通

| 章节   | 题目       | 厚度 | 时长 |
| ------ | ---------- | ---- | ---- |
| 第一章 | 绪论       | 10   | 20   |
| 第二章 | 线性表     | 50   | 100  |
| 第三章 | 栈和队列   | 43   | 100  |
| 第四章 | 串         | 15   | 30   |
| 第五章 | 树与二叉树 | 80   | 150  |
| 第六章 | 图         | 58   | 100  |
| 第七章 | 查找       | 36   | 60   |
| 第八章 | 排序       | 50   | 100  |

1. 数据结构的基本概念和术语，算法的描述和分析。
1. 线性表的逻辑结构，顺序存储结构，链式存储结构，及一元多项式的表示及相加。
1. 栈和队列的常用操作，及栈和队列的应用。
1. 串及其常用操作，了解串的应用。
1. 广义表的存储结构。
1. 树和二叉树的基本概念和性质，常用操作，遍历二叉树，线索二叉树，树和二叉树的转换，了解哈夫曼树。
1. 图的基本概念和性质，常用的图的存储结构，图的遍历，生存树和最小生存树，拓扑排序和关键路径以及最短路径。
1. 顺序查找，折半查找，二叉树查找，哈希表的查找及分析，平衡二叉树及B-树和B+树。
1. 冒泡排序，快速排序，选择排序，并归排序，基数排序，常用排序方法比较分析。



[toc]

$$
\LaTeX 测试
$$

# 绪论

考纲要求

​	数据结构的基本概念和术语，算法的描述和分析

细目：

1. 理解逻辑结构与物理结构之间的关系
1. 几种基本结构
1. ADT的表示和实现方法
1. 算法分析基础

## 数据结构的概念

### 数据 D

数据是信息的载体，是描述客观事物属性的数、字符及所有能输⼊到计算机中并被计算机程序识别和处理的**符号的集合**。

### 数据元素 DE

数据元素

数据元素是数据的基本单位。一个数据元素可由若干*数据项*组成，数据项是**构成数据元素**的**最小单位**。

### 数据对象 DO

具有相同性质的数据元素的集合，比如整数的数据对象是$N=\{0, \pm1, \pm2, \cdots\}$。

### 数据类型 DT

数据类型是⼀个**值的集合**和定义在此集合上的**⼀组操作**的总称。

1. 原子类型
1. 结构类型
1. 抽象数据类型 ADT

### 数据结构 DS

*数据结构*是相互之问存在⼀种或多种特定关系的数据元素的集合。在任何问题中，数据元素都不是孤立存在的，它们之间存在某种关系，这种数据元素相互之间的关系称为*结构（Structure）*。数据结构包括三⽅⾯的内容：逻辑结构、存储结构和数据的运算。

算法的**设计取决于所选定的逻辑结构**，⽽算法的**实现依赖于所采用的存储结构**。

## 数据结构三要素

### 逻辑结构

<img src="https://cdn.staticaly.com/gh/hankzhangcn/CDN@master/img/image-20230529214447777.4a4d4qm2i9w0.webp" alt="image-20230529214447777" />

1. 集合
1. 线性结构
1. 树形结构
1. 图状结构

### 存储结构

存储结构是指数据结构在计算机中的表示（映像）。它包括数据**元素的表示和关系的表示**。

1. 顺序存储
1. 链式存储
1. 索引存储
1. 散列存储

### 数据运算

运算的定义——逻辑结构——指出要做什么

运算的实现——存储结构——指出做的步骤

## 算法

1. 有穷性。⼀个算法必须总在执⾏有穷步之后结束，且每⼀步都可在有穷时间内完成。
1. 确定性。算法中每条指令必须有确切的含义，对于相同的输⼊只能得出相同的输出。
1. 可⾏性。算法中描述的操作都可以通过已经实现的基本运算执⾏有限次来实现。
1. 输⼊。算法有零个或多个输⼊，这些输⼊取⾃于某个特定的对象的集合。
1. 输出。算法有⼀个或多个输出，这些输出是与输⼊有着某种特定关系的量。

### 算法度量

#### 时间复杂度

##### 频度

语句在算法中被重复执行次数

所有语句的频度之和记为$T(n)$

由于基本运算的频度和$T(n)$数量级一样，所以可以用基本运算频度$f(n)$替代，记
$$
T(n)=O(f(n))
$$
易得
$$
0 \le T(n) \le Cf(n)
$$
C是正常数

##### 规模规则

算法的实际复杂度还跟输入的数据本身有关

1. 加法规则
1. 乘法规则

$$
O(1) < O(\log n) < O(n) < O (n\log n) < O(n^2) < O(n^3) < O(2^n) < O(n!) < O(n^n)
$$

#### 空间复杂度

只算辅助空间的规则，记 
$$
S(n)=O(g(n))
$$

## 练习 待补充

1. ⼀个算法应该是（）。
   A. 程序 
   B. 问题求解步骤的描述
   C. 要满足五个基本特性
   D. A和C

1. 算法的时间复杂度为 $O(n^2)$，表明该算法的（ ）。 
    A. 问题规模是$n^2$
    B. 执⾏时间等于$n^2$
    C. 执⾏时间与$n^2$成正比 
    D. 问题规模与$n^2$成正比

# 线性表

线性表的逻辑结构，顺序存储结构，链式存储结构，及一元多项式的表示及相加。

1. 掌握线性表的顺序存储方法和链式存储方法
1. 熟悉线性表的建立、插入、删除、搜索和~~归并算法~~
1. 了解一元多项式的表示方法及其应用

## 线性表的定义和操作

### 线性表的定义

线性表是具有相同数据类型的 n（n≥ 0）个数据元素的有限序列。

除第⼀个元素外，每个元素有且仅有一个直接前驱。除最后—个元素外，每个元素有且仅有⼀个直接后继。

### 线性表的操作

## 线性表的顺序表示

也叫顺序表。

**第1个元素**（从1开始）存储在线性表的起始位置，第i个元素的存储位置后⾯紧接着存储的是第i +1个元素，顺序表的特点是表中元素的逻辑顺序与其物理顺序相同。

<img src="https://cdn.staticaly.com/gh/hankzhangcn/CDN@master/img/image.15eyi9ymt6u8.webp" style="zoom: 67%;" />

### 线性表的分配

1. 静态分配

   ```c++
   #define MaxSize 50
   typedef struct{
   	ElemType data[MaxSize];
   	int length;
   }SqList;
   ```

1. 动态分配

   一旦数据空间与满，就另外开辟⼀块更⼤的存储空间，⽤以替换原来的存储空间

   动态分配并不是链式存储，它同样属于顺序存储结构，物理结构没有变化，依然是随机存取⽅式，只是分配的空间大小可以在运行时动态决定。 

   ```c++
   #define InitSize 100
   typedef struct{
   	ElemType *data;
   	int MaxSize, length;
   }SeqList;
   ```

   ```c++
   L.data=(ElemType*)malloc(sizeof(ElemType)*InitSize)
   ```

### 操作实现

1. 插入

   <img src="https://cdn.staticaly.com/gh/hankzhangcn/CDN@master/img/顺序表的插入.761b2r3j2kk0.webp" alt="顺序表的插入" />

1. 删除

   <img src="https://cdn.staticaly.com/gh/hankzhangcn/CDN@master/img/顺序表的删除.13ufuid7jmu8.webp" alt="顺序表的删除" style="zoom:67%;" />

1. 顺查

   <img src="https://cdn.staticaly.com/gh/hankzhangcn/CDN@master/img/顺序表的查找.6v4mso0m7t80.webp" alt="顺序表的查找" />

## 链式表示

### 定义

线性表的链式存储⼜称单链表，它是指通过⼀组任意的存储单元来存储线性表中的数据元素。

`data`为数据域，存放数据元素，`next`为指针域，存放后集结点的地址。

<img src="https://cdn.staticaly.com/gh/hankzhangcn/CDN@master/img/image.3mimc1xfawo0.webp" alt="image" style="zoom:67%;" />



```c
typedef struct LNode{
	ElemType data;
	struct LNode *next;
}LNode, *LinkList;
```

*请辨析上面的代码。*

通常⽤头指针来标识⼀个单链表，如单链表L，头指针为 NULL 时表示空表。此外，为了操作上的⽅便，在单链表第⼀个结点之前附加⼀个结点，称为头结点。头结点的数据域可以不设任何信息，也可以记录表⻓等信息。头结点的指针域指向线性表的第⼀个元素结点。

### 操作

#### 头插法

<img src="https://cdn.staticaly.com/gh/hankzhangcn/CDN@master/img/单链表的头插法.5fz2705tr840.webp" alt="单链表的头插法" />

每个结点插⼊的时间为 O（1），设单链表长为 n，则总时间复杂度为 O（n）。

<img src="https://cdn.staticaly.com/gh/hankzhangcn/CDN@master/img/image.35uvji7x4fs0.webp" alt="image" />

#### 尾插法

<img src="https://cdn.staticaly.com/gh/hankzhangcn/CDN@master/img/单链表的尾插法.1i7yt914mxxc.webp" alt="单链表的尾插法" />

该⽅法将新结点插⼊到当前链表的表尾，为此必须增加⼀个尾指针 r，使其始终指向当前链表的尾结点。

#### 按序号查找

#### 按值查找

### 双链表

<img src="https://cdn.staticaly.com/gh/hankzhangcn/CDN@master/img/image.2yc75ek9ik20.webp" alt="image" />

#### 插入

#### 删除

### 循环链表

表中最后⼀个结点的指针不是 NULL，⽽改为指向头结点，

### 静态链表

静态链表借助数组来描述线性表的链式存储结构，结点也有数据域 data 和指针域 next，与前⾯所讲的链表中的指针不同的是，这⾥的指针是结点的相对地址（数组下标），称游标。和顺序表⼀样，静态链表也要预先分配一块连续的内存空间。

## 一元多项式

对于一个一元n次多项式，其可以表示成为如下一般形式：
$$
f(x)=a_nX^n+a_{n-1}X^{n-1}+\cdots+a_2X^2+a_1X+a_0
$$
可以认为，要表示一个一元多项式，需要知道系数$a_i$和对应的指数$i$。可以用顺序表和链表存储系数和指数。

### 应用

#### 输入和输出

需要输入的信息有多项式的系数和指数，用来向系统动态申请内存；系数和指数用来构造每个结点，形成表。输入要求在程序运行过程中有提升，输出即对一元多项式进行遍历输出。

#### 多项式的加减

多项式的加减要指数相同的同类项才能实现，所以需要在运行中对各种不同情况进行判断，最后得到的结果存到新的表中，形成一个新的多项式。

#### 求多项式$f(x)$的值

可以对输入的两个一元多项式及其经过加、减运算得到的新的一元多项式进行计算，只要给出 x 的值，即可求得多项式的结果。

### 线性表的选择

1. 若输入的一元多项式是项数固定且指数依次递增的系数非 0 项，在不需要经常进行插入、删除某一项的情况下，选择顺序表。即是因为在上述情形下无论采用顺序还是链式的存储方式，需要的空间都是一样，但是使用顺序表可以在操作上有效降低时间的复杂度。
1. 若输入的一元多项式的项数不固定，且指数不是依次递增的式子，需要经常进行插入、删除的情况下，选择链表。即是因为在上述情形下每个结点代表一个项，多项式的每一项可以用其系数和指数唯一的表示，方便进行插入、删除等操作，在操作上有效降低空间的复杂度。

### 设计





~~~mermaid
graph TD
start((开始)) --> 1(申请结点)
1 --> 2(输入多项式的项数)
2 --> 3(输入多项式系数x, 指数y)
3 --> 4(输出多项式的内容)
4 --> 5((对多项式进行加减运算))
5 --> 6(输出经过运算的多项式)
6 --> 7((输入多项式的自变量x))
7 --> 8(输出多项式的值)
~~~

#### 数据逻辑结构

顺序表和链表的逻辑结构均相同，先对需要存储输入一元多项式的表进行初始化，再输入多项式的项数和多项式的系数、指数，重复两次，再选择是否进行加 \ 减运算，然后输入 x 的值，最后得到需要求的多项式的值。

#### 数据存储结构

顺序表的存储结构，是一个空间连续的表，通过下标来寻找数据元素，通过对数据的下标增加 \ 减少来遍历整个表。
链式的存储结构，是一个线性的但空间不连续的表，通过头结点来访问链表，每一个结点具有数据域和指针域，通过指针域来存储下一个元素的地址，然后一个个地进行遍历。

<img src="https://cdn.staticaly.com/gh/hankzhangcn/CDN@master/img/image.1sd2kpv8qzr4.webp" alt="在这里插入图片描述" style="zoom:150%;" />

```c++
typedef struct
{
	float coef; //系数
	int	exp; //指数
} Node;
```

```c++
typedef struct polynmial
{
	float coef; //系数
	int exp; //指数

	struct polynmial *next; //指针
} Node, *LinkList;
```

### 算法

顺序表中，先对两个多项式的第一项进行分析，若两项不相等，则先把小的一项放入新的表中，先放入一项的多项式下标加 1 用下一项和另一个多项式的第一项进行对比；若两项相等，则判断两项系数相加 \ 减是否为 0，若为 0 则两个多项式均自增到下一项进行比较；若不为 0，则将得到的系数和表 A 的指数放入新的表中作为一项。如此循环对比，直到一个表到最后一项，然后再判断哪一个表不为空，将该表剩余的项均放入新的表中；若两个表刚刚好项数项数，则无需进行下一步。最后得到新的一元多项式。

<img src="https://cdn.staticaly.com/gh/hankzhangcn/CDN@master/img/image.3ve4we4obes0.webp" alt="在这里插入图片描述" />

链表中，先对两个多项式的第一项进行分析，若两项相等，则判断两项系数相加 \ 减是否为 0，若为 0 则两个多项式均自增到下一项进行比较；若不为 0，则将得到的系数和表 A 的指数放入新的表中作为一项；若两项不相等，则先把小的一项放入新的表中，先放入一项的多项式下标加 1 用下一项和另一个多项式的第一项进行对比。如此循环对比，直到一个表到最后一项，然后再判断哪一个表不为空，将该表剩余的项均放入新的表中；若两个表刚刚好项数项数，则无需进行下一步。最后得到新的一元多项式。

<img src="https://cdn.staticaly.com/gh/hankzhangcn/CDN@master/img/image.4pr6ns3r3ci0.webp" alt="在这里插入图片描述" />