数据结构速通

| 章节   | 题目       | 厚度 | 时长 |
| ------ | ---------- | ---- | ---- |
| 第一章 | 绪论       | 10   | 20   |
| 第二章 | 线性表     | 50   | 100  |
| 第三章 | 栈和队列   | 43   | 100  |
| 第四章 | 串         | 15   | 30   |
| 第五章 | 树与二叉树 | 80   | 150  |
| 第六章 | 图         | 58   | 100  |
| 第七章 | 查找       | 36   | 60   |
| 第八章 | 排序       | 50   | 100  |

1. 数据结构的基本概念和术语，算法的描述和分析。
1. 线性表的逻辑结构，顺序存储结构，链式存储结构，及一元多项式的表示及相加。
1. 栈和队列的常用操作，及栈和队列的应用。
1. 串及其常用操作，了解串的应用。
1. 广义表的存储结构。
1. 树和二叉树的基本概念和性质，常用操作，遍历二叉树，线索二叉树，树和二叉树的转换，了解哈夫曼树。
1. 图的基本概念和性质，常用的图的存储结构，图的遍历，生存树和最小生存树，拓扑排序和关键路径以及最短路径。
1. 顺序查找，折半查找，二叉树查找，哈希表的查找及分析，平衡二叉树及B-树和B+树。
1. 冒泡排序，快速排序，选择排序，并归排序，基数排序，常用排序方法比较分析。

$$
\LaTeX 测试
$$



[toc]





# 绪论

考纲要求

​	数据结构的基本概念和术语，算法的描述和分析

细目：

1. 理解逻辑结构与物理结构之间的关系
1. 几种基本结构
1. ADT的表示和实现方法
1. 算法分析基础

## 数据结构的概念

### 数据 D

数据是信息的载体，是描述客观事物属性的数、字符及所有能输⼊到计算机中并被计算机程序识别和处理的**符号的集合**。

### 数据元素 DE

数据元素

数据元素是数据的基本单位。一个数据元素可由若干*数据项*组成，数据项是**构成数据元素**的**最小单位**。

### 数据对象 DO

具有相同性质的数据元素的集合，比如整数的数据对象是 $N=\{0, \pm1, \pm2, \cdots\}$ 。

### 数据类型 DT

数据类型是⼀个**值的集合**和定义在此集合上的**⼀组操作**的总称。

1. 原子类型
1. 结构类型
1. 抽象数据类型 ADT

### 数据结构 DS

*数据结构*是相互之问存在⼀种或多种特定关系的数据元素的集合。在任何问题中，数据元素都不是孤立存在的，它们之间存在某种关系，这种数据元素相互之间的关系称为*结构（Structure）*。数据结构包括三⽅⾯的内容：逻辑结构、存储结构和数据的运算。

算法的**设计取决于所选定的逻辑结构**，⽽算法的**实现依赖于所采用的存储结构**。

## 数据结构三要素

### 逻辑结构

<img src="https://cdn.staticaly.com/gh/hankzhangcn/CDN@master/img/image-20230529214447777.4a4d4qm2i9w0.webp" alt="image-20230529214447777" />

1. 集合
1. 线性结构
1. 树形结构
1. 图状结构

### 存储结构

存储结构是指数据结构在计算机中的表示（映像）。它包括数据**元素的表示和关系的表示**。

1. 顺序存储
1. 链式存储
1. 索引存储
1. 散列存储

### 数据运算

运算的定义——逻辑结构——指出要做什么

运算的实现——存储结构——指出做的步骤

## 算法

1. 有穷性。⼀个算法必须总在执⾏有穷步之后结束，且每⼀步都可在有穷时间内完成。
1. 确定性。算法中每条指令必须有确切的含义，对于相同的输⼊只能得出相同的输出。
1. 可⾏性。算法中描述的操作都可以通过已经实现的基本运算执⾏有限次来实现。
1. 输⼊。算法有零个或多个输⼊，这些输⼊取⾃于某个特定的对象的集合。
1. 输出。算法有⼀个或多个输出，这些输出是与输⼊有着某种特定关系的量。

### 算法度量

#### 时间复杂度

##### 频度

语句在算法中被重复执行次数

所有语句的频度之和记为 $T(n)$

由于基本运算的频度和 $T(n)$ 数量级一样，所以可以用基本运算频度 $f(n)$ 替代，记

$$
T(n)=O(f(n))
$$

易得

$$
0 \le T(n) \le Cf(n)
$$

C是正常数

##### 规模规则

算法的实际复杂度还跟输入的数据本身有关

1. 加法规则
1. 乘法规则

$$
O(1) < O(\log n) < O(n) < O (n\log n) < O(n^2) < O(n^3) < O(2^n) < O(n!) < O(n^n)
$$

#### 空间复杂度

只算辅助空间的规则，记 

$$
S(n)=O(g(n))
$$

## 练习

P17～21


<img src="https://cdn.staticaly.com/gh/hankzhangcn/CDN@master/img/image.6l8s8h97uqg0.webp" alt="image" />

<img src="https://cdn.staticaly.com/gh/hankzhangcn/CDN@master/img/image.2wdzrxtj08o0.webp" alt="image" style="zoom:67%;" />

<img src="https://cdn.staticaly.com/gh/hankzhangcn/CDN@master/img/image.5d5u8le9ydw0.webp" alt="image" style="zoom:67%;" />

<img src="https://cdn.staticaly.com/gh/hankzhangcn/CDN@master/img/image.ez7eb0qwl5s.webp" alt="image" />

<img src="https://cdn.staticaly.com/gh/hankzhangcn/CDN@master/img/image.6z20zozgj5c0.webp" alt="image" />

# 线性表

线性表的逻辑结构，顺序存储结构，链式存储结构，及一元多项式的表示及相加。

1. 掌握线性表的顺序存储方法和链式存储方法
1. 熟悉线性表的建立、插入、删除、搜索和~~归并算法~~
1. 了解一元多项式的表示方法及其应用

## 线性表的定义和操作

### 线性表的定义

线性表是具有相同数据类型的 n（n≥ 0）个数据元素的有限序列。

除第⼀个元素外，每个元素有且仅有一个直接前驱。除最后—个元素外，每个元素有且仅有⼀个直接后继。

### 线性表的操作

## 线性表的顺序表示

也叫顺序表。

**第1个元素**（从1开始）存储在线性表的起始位置，第i个元素的存储位置后⾯紧接着存储的是第i +1个元素，顺序表的特点是表中元素的逻辑顺序与其物理顺序相同。

<img src="https://cdn.staticaly.com/gh/hankzhangcn/CDN@master/img/image.15eyi9ymt6u8.webp" style="zoom: 67%;" />

### 线性表的分配

1. 静态分配

   ```c++
   #define MaxSize 50
   typedef struct{
   	ElemType data[MaxSize];
   	int length;
   }SqList;
   ```

1. 动态分配

   一旦数据空间与满，就另外开辟⼀块更⼤的存储空间，⽤以替换原来的存储空间

   动态分配并不是链式存储，它同样属于顺序存储结构，物理结构没有变化，依然是随机存取⽅式，只是分配的空间大小可以在运行时动态决定。 

   ```c++
   #define InitSize 100
   typedef struct{
   	ElemType *data;
   	int MaxSize, length;
   }SeqList;
   ```

   ```c++
   L.data=(ElemType*)malloc(sizeof(ElemType)*InitSize)
   ```

### 操作实现

1. 插入

   <img src="https://cdn.staticaly.com/gh/hankzhangcn/CDN@master/img/顺序表的插入.761b2r3j2kk0.webp" alt="顺序表的插入" />

1. 删除

   <img src="https://cdn.staticaly.com/gh/hankzhangcn/CDN@master/img/顺序表的删除.13ufuid7jmu8.webp" alt="顺序表的删除" style="zoom:67%;" />

1. 顺查

   <img src="https://cdn.staticaly.com/gh/hankzhangcn/CDN@master/img/顺序表的查找.6v4mso0m7t80.webp" alt="顺序表的查找" />

## 链式表示

### 定义

线性表的链式存储⼜称单链表，它是指通过⼀组任意的存储单元来存储线性表中的数据元素。

`data`为数据域，存放数据元素，`next`为指针域，存放后集结点的地址。

<img src="https://cdn.staticaly.com/gh/hankzhangcn/CDN@master/img/image.3mimc1xfawo0.webp" alt="image" style="zoom:67%;" />



```c
typedef struct LNode{
	ElemType data;
	struct LNode *next;
}LNode, *LinkList;
```

*请辨析上面的代码。*

通常⽤头指针来标识⼀个单链表，如单链表L，头指针为 NULL 时表示空表。此外，为了操作上的⽅便，在单链表第⼀个结点之前附加⼀个结点，称为头结点。头结点的数据域可以不设任何信息，也可以记录表⻓等信息。头结点的指针域指向线性表的第⼀个元素结点。

### 操作

#### 头插法

<img src="https://cdn.staticaly.com/gh/hankzhangcn/CDN@master/img/单链表的头插法.5fz2705tr840.webp" alt="单链表的头插法" />

每个结点插⼊的时间为 O（1），设单链表长为 n，则总时间复杂度为 O（n）。

<img src="https://cdn.staticaly.com/gh/hankzhangcn/CDN@master/img/image.35uvji7x4fs0.webp" alt="image" />

#### 尾插法

<img src="https://cdn.staticaly.com/gh/hankzhangcn/CDN@master/img/单链表的尾插法.1i7yt914mxxc.webp" alt="单链表的尾插法" />

该⽅法将新结点插⼊到当前链表的表尾，为此必须增加⼀个尾指针 r，使其始终指向当前链表的尾结点。

#### 按序号查找

#### 按值查找

### 双链表

<img src="https://cdn.staticaly.com/gh/hankzhangcn/CDN@master/img/image.2yc75ek9ik20.webp" alt="image" />

#### 插入

#### 删除

### 循环链表

表中最后⼀个结点的指针不是 NULL，⽽改为指向头结点，

### 静态链表

静态链表借助数组来描述线性表的链式存储结构，结点也有数据域 data 和指针域 next，与前⾯所讲的链表中的指针不同的是，这⾥的指针是结点的相对地址（数组下标），称游标。和顺序表⼀样，静态链表也要预先分配一块连续的内存空间。

## 一元多项式

对于一个一元n次多项式，其可以表示成为如下一般形式：

$$
f(x)=a_nX^n+a_{n-1}X^{n-1}+\cdots+a_2X^2+a_1X+a_0
$$

可以认为，要表示一个一元多项式，需要知道系数 $a_i$ 和对应的指数 $i$ 。可以用顺序表和链表存储系数和指数。

### 应用

#### 输入和输出

需要输入的信息有多项式的系数和指数，用来向系统动态申请内存；系数和指数用来构造每个结点，形成表。输入要求在程序运行过程中有提升，输出即对一元多项式进行遍历输出。

#### 多项式的加减

多项式的加减要指数相同的同类项才能实现，所以需要在运行中对各种不同情况进行判断，最后得到的结果存到新的表中，形成一个新的多项式。

#### 求多项式 $f(x)$ 的值

可以对输入的两个一元多项式及其经过加、减运算得到的新的一元多项式进行计算，只要给出 x 的值，即可求得多项式的结果。

### 线性表的选择

1. 若输入的一元多项式是项数固定且指数依次递增的系数非 0 项，在不需要经常进行插入、删除某一项的情况下，选择顺序表。即是因为在上述情形下无论采用顺序还是链式的存储方式，需要的空间都是一样，但是使用顺序表可以在操作上有效降低时间的复杂度。
1. 若输入的一元多项式的项数不固定，且指数不是依次递增的式子，需要经常进行插入、删除的情况下，选择链表。即是因为在上述情形下每个结点代表一个项，多项式的每一项可以用其系数和指数唯一的表示，方便进行插入、删除等操作，在操作上有效降低空间的复杂度。

### 设计

~~~mermaid
graph TD
start((开始)) --> 1(申请结点)
1 --> 2(输入多项式的项数)
2 --> 3(输入多项式系数x, 指数y)
3 --> 4(输出多项式的内容)
4 --> 5((对多项式进行加减运算))
5 --> 6(输出经过运算的多项式)
6 --> 7((输入多项式的自变量x))
7 --> 8(输出多项式的值)
~~~

#### 数据逻辑结构

顺序表和链表的逻辑结构均相同，先对需要存储输入一元多项式的表进行初始化，再输入多项式的项数和多项式的系数、指数，重复两次，再选择是否进行加 \ 减运算，然后输入 x 的值，最后得到需要求的多项式的值。

#### 数据存储结构

顺序表的存储结构，是一个空间连续的表，通过下标来寻找数据元素，通过对数据的下标增加 \ 减少来遍历整个表。
链式的存储结构，是一个线性的但空间不连续的表，通过头结点来访问链表，每一个结点具有数据域和指针域，通过指针域来存储下一个元素的地址，然后一个个地进行遍历。

<img src="https://cdn.staticaly.com/gh/hankzhangcn/CDN@master/img/image.1sd2kpv8qzr4.webp" alt="在这里插入图片描述" style="zoom:150%;" />

```c++
typedef struct
{
	float coef; //系数
	int	exp; //指数
} Node;
```

```c++
typedef struct polynmial
{
	float coef; //系数
	int exp; //指数

	struct polynmial *next; //指针
} Node, *LinkList;
```

### 算法

顺序表中，先对两个多项式的第一项进行分析，若两项不相等，则先把小的一项放入新的表中，先放入一项的多项式下标加 1 用下一项和另一个多项式的第一项进行对比；若两项相等，则判断两项系数相加 \ 减是否为 0，若为 0 则两个多项式均自增到下一项进行比较；若不为 0，则将得到的系数和表 A 的指数放入新的表中作为一项。如此循环对比，直到一个表到最后一项，然后再判断哪一个表不为空，将该表剩余的项均放入新的表中；若两个表刚刚好项数项数，则无需进行下一步。最后得到新的一元多项式。

<img src="https://cdn.staticaly.com/gh/hankzhangcn/CDN@master/img/image.3ve4we4obes0.webp" alt="在这里插入图片描述" />

链表中，先对两个多项式的第一项进行分析，若两项相等，则判断两项系数相加 \ 减是否为 0，若为 0 则两个多项式均自增到下一项进行比较；若不为 0，则将得到的系数和表 A 的指数放入新的表中作为一项；若两项不相等，则先把小的一项放入新的表中，先放入一项的多项式下标加 1 用下一项和另一个多项式的第一项进行对比。如此循环对比，直到一个表到最后一项，然后再判断哪一个表不为空，将该表剩余的项均放入新的表中；若两个表刚刚好项数项数，则无需进行下一步。最后得到新的一元多项式。

<img src="https://cdn.staticaly.com/gh/hankzhangcn/CDN@master/img/image.4pr6ns3r3ci0.webp" alt="在这里插入图片描述" />

## 习题

### 25 

<img src="https://cdn.staticaly.com/gh/hankzhangcn/CDN@master/img/image.2pcjph2a92i0.webp" alt="image" />

### 29

<img src="https://cdn.staticaly.com/gh/hankzhangcn/CDN@master/img/image.6ga9oq8irww0.webp" alt="image" />

<img src="https://cdn.staticaly.com/gh/hankzhangcn/CDN@master/img/image.2vc6ly692p00.webp" alt="image" />

### 48

<img src="https://cdn.staticaly.com/gh/hankzhangcn/CDN@master/img/image.49bij78i4xy0.webp" alt="image" />

<img src="https://cdn.staticaly.com/gh/hankzhangcn/CDN@master/img/image.5ez4dlcktcg0.webp" alt="image" />

<img src="https://cdn.staticaly.com/gh/hankzhangcn/CDN@master/img/image.3zznjpk88xw0.webp" alt="image" />

<img src="https://cdn.staticaly.com/gh/hankzhangcn/CDN@master/img/image.bjqc6jsfc74.webp" alt="image" /> 

<img src="https://cdn.staticaly.com/gh/hankzhangcn/CDN@master/img/image.7dxa048f5w40.webp" alt="image" /> 

# 栈和队列

推荐时长：100分钟

考纲要求：栈和队列的常用操作，及栈和队列的应用。

<img src="https://cdn.staticaly.com/gh/hankzhangcn/CDN@master/img/栈和队列导图.42uuebexq600.webp" alt="栈和队列导图" />

## 栈

### 概念

1. 什么是栈
   1. 栈顶
   1. 栈底
   1. 空栈
   1. 栈的特性：先入后出LIFO

   <img src="https://cdn.staticaly.com/gh/hankzhangcn/CDN@master/img/栈的示意图.4nagvrlr7hc0.webp" alt="栈的示意图" />

1. 栈的操作
   1. `InitStack(&Stack)`
   1. `StackEmpty(Stack)`
   1. `Push(&Stack,x)`
   1. `Pop(&Stack,&x)`
   1. `GetTop(Stack,&x)`
   1. `DestroyStack(&Stack)`

### 顺序栈

#### 存储结构

地址连续的存储单元，从栈底到栈顶依次存放，付有一个指针`top`指示栈顶元素。

```C++
#define MaxSize 50
typedef struct{
   Elemtype data[MaxSize];
   int top；
}SqStack；
```

#### 运算

<img src="https://cdn.staticaly.com/gh/hankzhangcn/CDN@master/img/image.2ogn81xgep40.webp" alt="image" />

> 关于`top`指针的取值规则，一般从`-1`开始，指向最顶部的元素（空为-1）。
>
> 如何判断栈中元素个数、是否为空，是否为满?

#### 共享栈

<img src="https://cdn.staticaly.com/gh/hankzhangcn/CDN@master/img/共享栈.1fx266sd1jkw.webp" alt="共享栈" />

> 如何判断两个栈中元素个数、是否为空，是否为满?

### 链栈

实质上即为头插法的单链表

优点是便于多个栈共享存储空间和提高其效率，且不存在栈满上溢的情况。


<img src="https://cdn.staticaly.com/gh/hankzhangcn/CDN@master/img/image.2xr84mfexuo0.webp" alt="image" />

### 习题 10 道，80

<img src="https://cdn.staticaly.com/gh/hankzhangcn/CDN@master/img/image.gfvtbeq5pc8.webp" alt="image" />

## 队列

### 概念

只允许在一段插入，另一段删除。

特点是先入后出FIFO

### 操作
1. `InitQueue(&Q)`
1. `QueueEmpty(Q)`
1. `EnQueue (&Q,x)`
1. `DeQueue (&Q，&x)`
1. `GetHead(Q,&x)`


<img src="https://cdn.staticaly.com/gh/hankzhangcn/CDN@master/img/image.5rivhap26w00.webp" alt="image" />

### 顺序存储结构

一块连续的存储区域，队头指针`front`指向队头元素，对尾指针`rear`指向队尾元素的**下一个元素**。

```C++
#define MaxSize 50
typedef struct{
   ElemType data[MaxSize];
   int front, rear;
}SqQueue;
```

<img src="https://cdn.staticaly.com/gh/hankzhangcn/CDN@master/img/image.6ttgvsr3aic0.webp" alt="image" />

> 如何判断队空、满？ 什么是队列溢出？

循环队列

当队头指针`Q.front=MaxSize-1`时，当其再前进一位时指向`0`。

初始时: `Q.front=Q.rear=0`

队首指针进 1: `Q.front=(Q.front+1)%MaxSize`

队尾指针进1: `Q.rear=(Q.rear+1)%MaxSize`

队列长度: `(Q.rear+MaxSize-Q.front)%MaxSize`

> 队空还是队满？

在讨论`Q.front=Q.rear`时候，有可能是队伍空了，也有可能是队伍满了。
可以：
1. 牺牲一个单元  `rear->next is front`
1. 增设`Q.size`
1. 增加一个tag标志。删除导致的`Q.front=Q.rear`为队伍空，插入导致的`Q.front=Q.rear`为队伍满。

<img src="https://cdn.staticaly.com/gh/hankzhangcn/CDN@master/img/image.2hyp08m62960.webp" alt="image" />

###  链队

即为一个带队头指针和队尾指针的单链表。
头指针指向队头结点，尾指针指向**队尾结点**。

<img src="https://cdn.staticaly.com/gh/hankzhangcn/CDN@master/img/image.2upxi8tp5u00.webp" alt="image" />

一般使用带头结点的链表，方便插入和删除。

### 双端队列

在双端队列进队时，前端进的元素排列在队列中后端进的元素的前⾯，后端进的元素排列在从列中前端进的元素的后⾯。在双端队列出队时，⽆论是前端还是后端出队，先出的元素排列在后出的元素的前⾯。

<img src="https://cdn.staticaly.com/gh/hankzhangcn/CDN@master/img/image.2g8d7irmo3wg.webp" alt="image" />

#### 受限的双端队列

1. 输出受限的双端队列
1. 输入受限的双端队列

### 习题

<img src="https://cdn.staticaly.com/gh/hankzhangcn/CDN@master/img/image.3ifijp1kebe0.webp" alt="image" />

<img src="https://cdn.staticaly.com/gh/hankzhangcn/CDN@master/img/image.2shs48gegge0.webp" alt="image" />

## 栈和队列的应用

### 括号匹配-栈

假设表达式中允许包含两种括号∶ 圆括号和⽅括号，其嵌套的顺序任意即`[]()`或`([][])`等均为正确格式。

考虑
```plaintext
[  (  [  ]  [  ]  )  ]
1  2  3  4  5  6  7  8
```
如何用栈完成括号匹配


### 表达式求值-栈
前缀、中缀、后缀表达式

让我们通过例题来了解：

已知操作符包括 $+、-、\times、\div、（、）$ ，请将中缀表达式 $a+b-a\times((c+d)\div e-f)+g$ 转换为等价的后缀表达式 $ab+acd+e \div f- \times -g+$ 时，用栈来存放暂时还不能确定运算次序的操作符。若栈初始时为空，则转换过程中同时保存在栈中的操作符的最大个数是（   ）？
`A:5 B:7  C:8  D:11 `

<img src="https://cdn.staticaly.com/gh/hankzhangcn/CDN@master/img/image.89a256486w8.webp" alt="image" />

### 递归

把⼀个⼤型的复杂问题层层转化为⼀个与原问题相似的规模较⼩的问题来求解，

优点：代码少
缺点：占用多，容易溢出
### 层次遍历-队列
在信息处理中有⼀—⼤类问题需要逐层或逐⾏处理。这类问题的解决⽅法往往是在处理当前层或当前⾏时就对下⼀层或下⼀⾏做预处理，把处理顺序安排好，等到当前层或当前⾏处理完毕，就可以处理下⼀层或下⼀⾏。使⽤队列是为了保存下⼀步的处理顺序。

### 习题

<img src="https://cdn.staticaly.com/gh/hankzhangcn/CDN@master/img/image.1fbsikhtjuo0.webp" alt="image" />

<img src="https://cdn.staticaly.com/gh/hankzhangcn/CDN@master/img/image.1xx5exd5zbsw.webp" alt="image" />

<img src="https://cdn.staticaly.com/gh/hankzhangcn/CDN@master/img/image.6wccn882bcg0.webp" alt="image" />

## 矩阵压缩

### 存储结构
以⼀维数组 $A[0\dots n-1]$ 为例，其存储结构关系式为

$$
LOC(a_i)= LOC(a_0)+i\times L \space (0≤ i <n)
$$

L 是每个数组元素所占的存储单元。

对于多维数组
#### 行优先

$$
LOC(a_{i,j}) = LOC(a_{0,0}) +[ i \times ( h_2+1) +j ] \times  L
$$

#### 列优先

$$
LOC(a_{i,j}) = LOC(a_{0,0}) +[ j \times ( h_1+1) +i ] \times  L
$$

### 对称矩阵的压缩
对称矩阵 $A[1 \dots n][1 \dots n]$ 存放在⼀维数组 $B[n(n+1)/2]$中，即元素 $a_{i,j}$ 存放在 $b_k$ 中。只存放下三⻆部分（含主对⻆）的元素。

<img src="https://cdn.staticaly.com/gh/hankzhangcn/CDN@master/img/image.2mma3coldma0.webp" alt="image" />

### 三角矩阵

下三⻆矩阵中，上三⻆区的所有元素均为同⼀常量。其存储思想与对称矩阵类似，不同之处在于存储完下三⻆区和主对⻆线上的元素之后，紧接着存储对⻆线上⽅的常量⼀次。

<img src="https://cdn.staticaly.com/gh/hankzhangcn/CDN@master/img/image.5yv90ef6tso0.webp" alt="image" />

上三⻆矩阵中，下三⻆区的所有元素均为同⼀常量。只需存储主对⻆线、上三⻆区上的元素和下三
⻆区的常量⼀次。

<img src="https://cdn.staticaly.com/gh/hankzhangcn/CDN@master/img/image.bfw3fckyyiw.webp" alt="image" />

### 三对角矩阵

<img src="https://cdn.staticaly.com/gh/hankzhangcn/CDN@master/img/image.6vfgppemyc80.webp" alt="image" />

### 稀疏矩阵

仅存储⾮零元素。但通常零元素的分布没有规律，所以仅存储菲零元素的值是不够的，还要存储它所在的⾏和列。因此，将⾮零元素及其相应的⾏和列构成⼀个三元组（⾏标，列标，值），如图 3. 27 所示。然后按照某种规律存储这些三元组。稀疏矩阵压缩存储后便失去了随机存取特性。

<img src="https://cdn.staticaly.com/gh/hankzhangcn/CDN@master/img/image.6358xf8e2po0.webp" alt="image" />

### 习题 100

<img src="https://cdn.staticaly.com/gh/hankzhangcn/CDN@master/img/image.477zqu7evd80.webp" alt="image" />

<img src="https://cdn.staticaly.com/gh/hankzhangcn/CDN@master/img/image.4770aqu8st80.webp" alt="image" />

# 串
<img src="https://cdn.staticaly.com/gh/hankzhangcn/CDN@master/img/image.3g8cls197fg0.webp" alt="image" />

## 串的定义和实现
串（string）是由零个或多个字符组成的有限序列。⼀般记为 $S='a_1a_2 \cdots a_n' (n≥ 0)$ 其中，S 是串名，单引号括起来的字符序列是串的值; $a_i$可以是字⺟、数字或其他字符; 串中字符的个数 n 称为串的⻓度。n=0 时的串称为空串    $\empty$.

串中任意多个连续的字符组成的⼦序列称为该串的⼦串，相应地，包含⼦串的串称为主串。 某个字符在串中的序号称为该字符在串中的位置。

### 存储结构
#### 顺序存储
类似于线性表的顺序存储结构
```C++
#define MAXLEN 255
typedef struct{
   char ch[MAXLEN];
   int length;
}
```


#### 堆分配
在C语⾔中，存在⼀个称之为"堆"的⾃由存储区，并⽤ malloc （）和 free（）函数来完成动态存储管理。利⽤ malloc（）为每个新产⽣的串分配⼀块实际串⻓所需的存储空间，若分配成功，则返回⼀个指向起始地址的指针，作为串的基地址，这个串由 ch 指针来指示; 若分配失败，则返回 NULL。已分配的空间可⽤ free（）释放掉。
```C++
typedef struct{
   char *ch;
   int length;
}HString;
```

#### 块链存储表示
类似于线性表的链式存储结构，也可采⽤链表⽅式存储串值。由于串的特殊性（每个元素只有⼀个字），在具体实现时，每个结点既可以存放⼀个字符，也可以存放多个字符。每个结点称为块，整个链表称为块链结构。

<img src="https://cdn.staticaly.com/gh/hankzhangcn/CDN@master/img/image.5esx27o7sa00.webp" alt="image" />

### 基本操作
StrAssign(&T，chars): 赋值操作。把串 T 赋值为 chars。
strCopy(&T，s): 复制操作。由串 S 复制得到串 T。
strEmpty(S):判空操作。若 S 为空串，则返回 TRUE，否则返回 EALSE。
StrCompare(S,T): 比较操作。若 S>T，则返回值>0; 若 S=T，则返回值=0; 若 S<T则返回值<0。
strLength(S): 求串长。返回串 S 的元素个数。
Substring(&Sub,S,pos,len): 求子串。用 Sub 返回串 S 的第 pos 个字符起长度为len 的子串。
Concat (&T，S1,S2): 串联接。用T返回由 S1和 S2 联接而成的新串。
Index(S,T): 定位操作。若主串 S 中存在与串 T 值相同的子串，则返回它在主串 S 中第一次出现的位置，否则函数值为 0。
ClearString(&S): 清空操作。将 s 清为空串
DestroyString(&S): 销毁串。将串 S 销毁

## 模式匹配

### 简单模式匹配

⼦串的定位操作通常称为串的模式匹配，它求的是⼦串（常称模式串）在主串中的位置。

在上述算法中，分别用计数指针 i 和指示主串 S和模式串 T 中当前正待比较的字符位置。算法思想为:从主串 S 的第一个字符起，与模式 T的第一个字符比较若相等，则继续逐个比较后续字符，否则从主串的下一个字符起，重新和模式的字符比较，以此类推，直至模式 T中的每个字符依次和主串 S 中的一个连续的字符序列相等，则称匹配成功，函数值为与模式  中第一个字符相等的字符在主串 s 中的序号，否则称匹配不成功，函数值为零。图 4.2 展示了模式 T= abcac 和主串 S 的匹配过程，每次匹配失败后，都把模式 后移一位。

### KMP

#### 串的前缀、后缀、部分匹配

要了解子串的结构，首先要弄清楚几个概念:前缀、后缀和部分匹配值。前缀指除最后一字符以外，字符串的所有头部子串，后缀指除第一个字符外，字符串的所有尾部子串，部分匹配值则为字符串的前缀和后缀的最长相等前后缀长度。

<img src="https://cdn.staticaly.com/gh/hankzhangcn/CDN@master/img/image.2bu8ewmflxa8.webp" alt="image" />

利用上述方法容易写出子串 'abcac'的部分匹配值为 00010，将部分匹配值写成数组形式就得到了部分匹配值 (Partial Match,PM)的表。

<img src="https://cdn.staticaly.com/gh/hankzhangcn/CDN@master/img/image.gq0x2w1sda8.webp" alt="image" />

#### KMP原理

当 c 与b不匹配时，已匹配' abca' 的前缀 a和后缀 a为最⻓公共元素。已知前缀a 与b、c 均不同，与后缀a 相同，故⽆须⽐较，直接将⼦串移动"已匹配的字符数——对应的部分匹配值"，⽤⼦串前缀后⾯的元素与主串匹配失败的元素开始⽐较即可。
<img src="https://cdn.staticaly.com/gh/hankzhangcn/CDN@master/img/image.4tnleq1fge00.webp" alt="image" />

关于Next数组

<img src="https://cdn.staticaly.com/gh/hankzhangcn/CDN@master/img/image.5r6nl7d89io.webp" alt="image" />

1. 第一个元素右移以后空缺的用-1 来填充，因为若是第一个元素匹配失败，则需要将子串向右移动一位，而不需要计算子串移动的位数。
1. 最后一个元素在右移的过程中溢出，因为原来的子串中，最后一个元素的部分匹配值是其下一个元素使用的，但显然已没有下一个元素，故可以舍去。这样，上式就改写为
 $Move=(j-1)-next[j]$ 相当于将子串的比较指针  回退到 $j=j-Move=j-((j-1)-next[j])=next[j]+1$ .

### 改进的KMP

<img src="https://cdn.staticaly.com/gh/hankzhangcn/CDN@master/img/image.4lmsfyugwic.webp" alt="image" />

<img src="https://cdn.staticaly.com/gh/hankzhangcn/CDN@master/img/image.6tad7l2hzjo0.webp" alt="image" />

## 习题112 

<img src="https://cdn.staticaly.com/gh/hankzhangcn/CDN@master/img/image.1v5wcpaqpfk0.webp" alt="image" />